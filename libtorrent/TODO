SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Set IP TOS

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Recursively update the up/down rates in throttle.

Make a seperate class for doing read and write to buffer in PC.

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A proper
type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

SocketBase should use a stl::vector instead. This would require a
function that iterates through the vector and set new valid iterators
after a reserve/erase.

Using lists for the sockets we're waiting on does provide for many
cache misses. (i would assume). find out if you can't use something more
clever. Sort by fd number? iterate only to that number?

Cache iterators to different borders, and update them as we add/remove?

Use iterators in StorageChunk::get_position instead.

Look into epoll.

Willneed hash checking queue does not work optimally on large files
with very small chunks.


DUMPING TORRENT FILES

Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.


IMPORTANT

make sure handshake gets "" id if the download does not want connections,
or some other filter system.

DOCUMENTATION

As far as documentation is concerned: a step through example that shows all
the torren::init calls and sets up a download and doxygen comments in the
header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


CURRENT:

Fix low rates

Fix snub

Use m_writeThrottle to be consistent?

Throttle skipped pieces too.


NEXT:

Make a base class for PeerConnection, move read/write_remaining etc.

Make m_read{Piece,Chunk} placement consistent.

Add buffer read of piece.


NEXT:

Don't hash check more than X bytes at a time, add to timeout.

Cleanup HashQueue, seperate out nodes etc.

Make HashChunk::remaining inline.


RELEASE:

Remove debug checks in SocketSet. (Next release)


POLLING:

Consider sorting SocketSet so we can get maxFd cheaper. Epoll might
not need this, so consider the value.

Rename poll.h.

CLEANUP:

ref_anchored... urgh...