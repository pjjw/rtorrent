NOTE: These are personal TODO items that might, or might not be
implemented. They are just notes to keep me from forgetting ideas i
get while coding.

Check for validity of >4gb files.

Check that all priority queue inserts put themselves after
cachedTime. Look at window::mark_dirty.

Don't allow multiple connections from the same IP to the same
torrent. Also do something about incoming connections. Only let them
open N handshakes.

Either kill the setting of uninterested state, or fix the code.

Wildcards.


===

Don't use std::make_heap in rak::priority_queue, test that this is
safe.

When receiving zero length pieces, remove them from the queue.

Clean up the command/option instances, move them to Control.

Implement the generic command system thing.

Clean up the client-side handling of listening port open/reopen/close.

Fix the usage of std::min(s, length) in display/utils.cc, it won't
work correctly if an error is returned.

===


Look into replacing SocketAddress with some kind of thing using
getaddrinfo.

Display leechers/seeders.

Make sure storage error is correctly displayed, rather than being
hidden.

Different min peers for seeding and leeching modes?

Store data on which side inititalized the connection.


=== For the next API change ===

Rename hash_resume_save/load, it should be generic.

Split the resume interface.

Add API for checking the existance of files before we open stuff. BTW,
should we perhaps do lazy create on files not currently present? We
can add stuff to Entry to check this. Shouldn't create files unless
they are marked for download? But that might bork when we need to map
those regions.

===


=== Hash Resume save ===

[R] could you add a trigger for Download::hash_resume_save when a torrent 
finishes?  

Would need to make sure all chunks have been flushed.

===


<zzorn> if you think .file could be seriously abused, then feel free
to block (or perhaps warn??) about it

Move task scheduler to rak.

Testcase for mmap bug? Also look into dns lookup cache.

Set an upper limit on the number of send request a peer can queue.


=== Printing to display ===

Clean this up, especially file list.


Make sure to verify that the single file torrent gets a valid path,
also make sure no file can start with "." "..".

Look into iconv.

Add checks to ensure requested pieces are valid. Length etc. Also
fiddle with max queue length. This all needs to be cleaned up.

Fiddle pipe size.


== Delegator refactoring ==

Consider ways of avoid use of Delegator::slotChunkSize.

Allow some client request to span more than (1<<14) bytes. 

====


[R] I would like to request refreshing the screen on SIGWINCH and when you press Ctrl-L

Consider moving size checking outside of File::get_chunk.

Consider adding a check to make sure info_hash matches the session
torrent's file name?

Do chokes on long time unchoked peers when seeding to spread the upload more.

***

Make sure that when we stop a torrent and disconnects, that those
don't cause unchokes of soon to be disconnected peers. Create a
function that chokes all and doesn't allow new unchokes.

Move download initializiation stuff into Manager.

Rename most things to remote/local or something. up/down is too
confusing. Atleast add it to some of the function names.

Would be nice to refactor requester, it should own the bitfield in some way?

delegator's priorities are reset on DownloadMain::open? Make the
priority thing work right, don't use a seperate function for updating
them.

Consider asking for read-ahead for fast peers.

Unaligned 58.6.0.92     0.0

Do move of session torrent so we don't end up with incomplete torrent
files in case of crashes.

Make it possible to disable certain files, not causing an error when
they don't give rw perm or resize?

Clearer display of which torrents are stopped, make it into a seperate
column.

Re-add slot for removing incoming connections from available list? If
so, remove the check in connect_peers.

Move endgame detection to delegator?

Rename TrackerControl?

Remove get_ for certain class of accesses, also make them pointers to
put emphasis on the fact that they arn't logically behaving like
return-by-value types.

Add an intersection version off HandshakeManager::has_address()?

Clean up the header includes around the codebase, need to reduce the
amount of memory required to compile libtorrent.

Send mail to OpenBSD to see how they handle madvise.

Use a seperate function for handling epoll_ctl calls? With event and
op as args?

Consider renaming Poll::open/close.

Improve the settings code, it should read all settings before
initialization. Make some seperate settings class that holds all the
settings, that the user can view during runtime.

Look over the max open sockets settings etc, it should be
consistent. One should have a choice between using a setting that
changes sysconf(_SC_OPEN_MAX), or get the max value from this variable.

Add a setting for controlling whetever allocate is called at torrent
creation, chunk creation or not at all.

XFS reserve should check for error return code, if it fails due to
lack of diskspace it should return false, otherwise true.

Clean up the settings code by moving the validation to the apply'er.

Use typedef for port?

Add filter for ip address, and peer id. These must be seperate as ip
happens before handshake, but peer id is done after handshake or
before connecting.

Fix hash checking slowness on overworked boxens. Possibly mark the
mmap'ed area as sequential. Add options to the man page.

Expand ~/ in input.

Rewrite the chunk handler, use a vector that msyncs continious chunks
when it feels like it. Use a task to check periodically, or when
receiving chunks. Try to make sure we do sequential download of
chunks, instead of completely random.

Add a slot in core::DownloadList that makes it safe to delete
downloads at all times.

Use a seperate function for checking the hash status when doing
download starts.


*** STUFF I MIGHT DO SOME DAY ***

After 25 seconds, choke a peer if no requests have been received?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

std::isalpha in escape string

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


AFTER API REDESIGN:

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.

make sure handshake gets "" id if the download does not want
connections, or some other filter system.


DOCUMENTATION

As far as documentation is concerned: a step through example that
shows all the torren::init calls and sets up a download and doxygen
comments in the header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


Move mkdir stuff out of Path?

Lock file in session directory.
