NOTE: These are personal TODO items that might, or might not be
implemented. They are just notes to keep me from forgetting ideas i
get while coding.

[DONE] Make sure flushing happens...

Move download initializiation stuff into Manager.

Replace download_remove's info_hash thingie with Download.

Use partial sort, or nth_element.

Take upload speed into account when sorting.

Adjust cycle size according to unchoked size.

Uploading too fast?

Figure out if snubbing fscks up interested. Also a connection might be
(un)choked while setting (not)interested. urgh... think.

Consider balancing when adding downloads. Actually, won't do much good
as new downloads have no peers. Use a buffer of available unchokes?

Rename most things to remote/local or something. up/down is too
confusing. Atleast add it to some of the function names.

Make sure that when we stop a torrent and disconnects, that those
don't cause unchokes of soon to be disconnected peers.

Balance will be reserved for when we change the max unchoked.

Consider moving ResourceManager to src/

Use correctly sized read/write buffers.

Rewrite throttle code, consider not updating when unlimited. Do an
update when putting them into unlimited mode.

Consider MAP_NOSYNC.

Optimize interested, seperate return values for requesting where we
are still interested downloading from others and when we're not
interested anymore.

Would be nice to refactor requester, it should own the bitfield in some way?

Wait when receiving resource tmp unavailable. Currently need to close
the connection.

delegator's priorities are reset on DownloadMain::open? Make the
priority thing work right, don't use a seperate function for updating
them.

Consider asking for read-ahead for fast peers.

File priority might not like sequential requesting.

Cache the number of unchoked peers.

Unaligned 58.6.0.92     0.0

*** For the next API change ***

Rename hash_resume_save/load, it should be generic.

***

Do move of session torrent so we don't end up with incomplete torrent
files in case of crashes.

Make it possible to disable certain files, not causing an error when
they don't give rw perm or resize?

Clearer display of which torrents are stopped, make it into a seperate
column.

Move stuff into rak.

Slot in torrent/Peer for incoming, so we can use SocketAddress
internally?

Re-add slot for removing incoming connections from available list? If
so, remove the check in connect_peers.

Move endgame detection to delegator?

Make sure rtorrent's http downloading times out.

Different min peers for seeding and leeching modes?

Rename TrackerControl?

Remove get_ for certain class of accesses, also make them pointers to
put emphasis on the fact that they arn't logically behaving like
return-by-value types.

Add an intersection version off HandshakeManager::has_address()?

Clean up the header includes around the codebase, need to reduce the
amount of memory required to compile libtorrent.

Send mail to OpenBSD to see how they handle madvise.

Use a seperate function for handling epoll_ctl calls? With event and
op as args?

Consider renaming Poll::open/close.

Move ui::Control to src/, make the initialization functions part of it.

Improve the settings code, it should read all settings before
initialization. Make some seperate settings class that holds all the
settings, that the user can view during runtime.

Look over the max open sockets settings etc, it should be
consistent. One should have a choice between using a setting that
changes sysconf(_SC_OPEN_MAX), or get the max value from this variable.

Add a setting for controlling whetever allocate is called at torrent
creation, chunk creation or not at all.

XFS reserve should check for error return code, if it fails due to
lack of diskspace it should return false, otherwise true.

Clean up the settings code by moving the validation to the apply'er.

Use typedef for port?

Add filter for ip address, and peer id. These must be seperate as ip
happens before handshake, but peer id is done after handshake or
before connecting.

Make the tries adjuster into a setting.

Doesn't force in some cases when the system is overloaded and you got
small hash chunks.

Fix hash checking slowness on overworked boxens. Possibly mark the
mmap'ed area as sequential. Add options to the man page.

Expand ~/ in input.

Rewrite the chunk handler, use a vector that msyncs continious chunks
when it feels like it. Use a task to check periodically, or when
receiving chunks. Try to make sure we do sequential download of
chunks, instead of completely random.

Add a slot in core::DownloadList that makes it safe to delete
downloads at all times.

Check if BT 4.0.2 has problems with libtorrent.

Use a seperate function for checking the hash status when doing
download starts.

Possibly do sync before/after checking hash. Don't sync complete
chunks as they were synced at the time of hash checking? Read the list
of dirty chunks from the delegator. Need to fix the problem of corrupt
downloads due to lack of diskspace.

Ponder race condition on lazy hash checking, do new data get written
before we start checking?

The handling of hash fails isn't good enough...

Directory validation needs to be lazy?

Disable read/write_chunk exceptions.

Don't allow many handshakes from the same ip?

Create a std::list'ish thing that contains the current downloads, and
expose it to the client. Will make DownloadManager 'redundant'. Don't fix?



*** STUFF I MIGHT DO SOME DAY ***

SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A
proper type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


LONG TERM:

Make a collection of stuff in utils that can be shared between apps.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.

make sure handshake gets "" id if the download does not want
connections, or some other filter system.


DOCUMENTATION

As far as documentation is concerned: a step through example that
shows all the torren::init calls and sets up a download and doxygen
comments in the header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


Move mkdir stuff out of Path?

Cleanup HashQueue, seperate out nodes etc.  * Make it a private list.
* Don't pass Chunk in SlotDone.

Lock file in session directory.
