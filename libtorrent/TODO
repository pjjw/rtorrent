NOTE: These are personal TODO items that might, or might not be
implemented. They are just notes to keep me from forgetting ideas i
get while coding.

Crash on viewing files during hash check or something?

(Delete, up)
4 /uio/hegel/s02/jaris/local/lib/libtorrent.so.5(_ZN7torrent7ContentD1Ev+0x19b) [0xb7f81f3b]
5 /uio/hegel/s02/jaris/local/lib/libtorrent.so.5(_ZN7torrent12DownloadMainD1Ev+0xc8b) [0xb7f9663b]
6 /uio/hegel/s02/jaris/local/lib/libtorrent.so.5(_ZN7torrent15DownloadWrapperD1Ev+0x6e) [0xb7f9c9b2]
7 /uio/hegel/s02/jaris/local/lib/libtorrent.so.5(_ZN7torrent15DownloadManager5eraseESt14_List_iteratorIPNS_15DownloadWrapperEE+0xc9) [0xb7f99f9d]
8 /uio/hegel/s02/jaris/local/lib/libtorrent.so.5(_ZN7torrent15download_removeERKSs+0x3f) [0xb7f7a98f]

"TaskScheduler::insert(...) tried to insert an already inserted or invalid TaskItem"

Use last choked time when receiving not/interested, this avoids the
task delay. We already have a 30 second cycle at work. Need to modify
choke cycle being called when receiving not-interested etc?

Make unchoking of peers when receiving interested go through the choke
manager. This will be used to avoid oscillation of choke status.

Make closing of seeding peers at torrent completion a part of the done
signal.

Optimize interested, seperate return values for requesting where we
are still interested downloading from others and when we're not
interested anymore.

Would be nice to refactor requester, it should own the bitfield in some way?

Rename receive_have_chunk.

Wait when receiving resource tmp unavailable. Currently need to close
the connection.

delegator's priorities are reset on DownloadMain::open? Make the
priority thing work right, don't use a seperate function for updating
them.

Consider asking for read-ahead for fast peers.

File priority might not like sequential requesting.

Use correctly sized read/write buffers.

Cache the number of unchoked peers.

Change all get_chunk(...)'s to check for only is_valid, not NULL?

Unaligned 58.6.0.92     0.0

*** After PeerConnection is killed ***

PeerConnectionBase::read_cancel_piece should only check for
WRITE_PIECE when doing cancel or something.

*** For the next API change ***

Rename hash_resume_save/load, it should be generic.

***

Do move of session torrent so we don't end up with incomplete torrent
files in case of crashes.

Make it possible to disable certain files, not causing an error when
they don't give rw perm or resize?

Clearer display of which torrents are stopped, make it into a seperate
column.

Move stuff into rak.

Slot in torrent/Peer for incoming, so we can use SocketAddress
internally?

Re-add slot for removing incoming connections from available list? If
so, remove the check in connect_peers.

Move endgame detection to delegator?

Make sure rtorrent's http downloading times out.

Different min peers for seeding and leeching modes?

Rename TrackerControl?

Remove get_ for certain class of accesses, also make them pointers to
put emphasis on the fact that they arn't logically behaving like
return-by-value types.

Add an intersection version off HandshakeManager::has_address()?

Clean up the header includes around the codebase, need to reduce the
amount of memory required to compile libtorrent.

Make a seperate Download tracker class thing that handles re-requests
etc. Move control logic from TrackerControl.

Send mail to OpenBSD to see how they handle madvise.

Use a seperate function for handling epoll_ctl calls? With event and
op as args?

Consider renaming Poll::open/close.

Move ui::Control to src/, make the initialization functions part of it.

Improve the settings code, it should read all settings before
initialization. Make some seperate settings class that holds all the
settings, that the user can view during runtime.

Look over the max open sockets settings etc, it should be
consistent. One should have a choice between using a setting that
changes sysconf(_SC_OPEN_MAX), or get the max value from this variable.

Add a setting for controlling whetever allocate is called at torrent
creation, chunk creation or not at all.

XFS reserve should check for error return code, if it fails due to
lack of diskspace it should return false, otherwise true.

Clean up the settings code by moving the validation to the apply'er.

Use typedef for port?

Add filter for ip address, and peer id. These must be seperate as ip
happens before handshake, but peer id is done after handshake or
before connecting.

Make the tries adjuster into a setting.

Doesn't force in some cases when the system is overloaded and you got
small hash chunks.

Fix hash checking slowness on overworked boxens. Possibly mark the
mmap'ed area as sequential. Add options to the man page.

Expand ~/ in input.

Rewrite the chunk handler, use a vector that msyncs continious chunks
when it feels like it. Use a task to check periodically, or when
receiving chunks. Try to make sure we do sequential download of
chunks, instead of completely random.

Add a slot in core::DownloadList that makes it safe to delete
downloads at all times.

Check if BT 4.0.2 has problems with libtorrent.

Use a seperate function for checking the hash status when doing
download starts.

Possibly do sync before/after checking hash. Don't sync complete
chunks as they were synced at the time of hash checking? Read the list
of dirty chunks from the delegator. Need to fix the problem of corrupt
downloads due to lack of diskspace.

Do truncate to update the timestamp, so we know he filestamp is
updated.

Do sync on all stopped downloads. Ftruncate a torrent upon load to set
its timestamp.

Rewrite the read buffering in PeerConnection, don't do so many small
reads.

Ponder race condition on lazy hash checking, do new data get written
before we start checking?

The handling of hash fails isn't good enough...

Directory validation needs to be lazy?

Disable read/write_chunk exceptions.

Don't allow many handshakes from the same ip?

Copy modifications of timer.h to rtorrent. Wait... first from rtorrent to libtorrent.

Create a std::list'ish thing that contains the current downloads, and
expose it to the client. Will make DownloadManager 'redundant'. Don't fix?



*** STUFF I MIGHT DO SOME DAY ***

SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A
proper type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


LONG TERM:

Make a collection of stuff in utils that can be shared between apps.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Look into epoll and sendfile.


Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.

make sure handshake gets "" id if the download does not want
connections, or some other filter system.

DOCUMENTATION

As far as documentation is concerned: a step through example that
shows all the torren::init calls and sets up a download and doxygen
comments in the header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


Move mkdir stuff out of Path?

Cleanup HashQueue, seperate out nodes etc.  * Make it a private list.
* Don't pass Chunk in SlotDone.

SocketManager must be enabled.

Use ProtocolBuffer for skip piece too.

Make the stable buffer in throttle be more dynamic depending on the
current rate.

Optimize ChokeManager::get_unchoked.

Add buffer read of piece.

Fix tracker so it checks regulary when too few peers are connected.

Lock file in session directory.


BUGS:

Snubing seems borked... why?

Don't use function pointers in throttle, templates should work as well.

Throttle might not give correct size when for_each'ing each, since
zero byte quotas might accure.
