SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A proper
type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


LONG TERM:

Make a collection of stuff in utils that can be shared between apps.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Look into epoll and sendfile.


Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.

make sure handshake gets "" id if the download does not want connections,
or some other filter system.

DOCUMENTATION

As far as documentation is concerned: a step through example that shows all
the torren::init calls and sets up a download and doxygen comments in the
header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


Move mkdir stuff out of Path?

Cleanup HashQueue, seperate out nodes etc.
* Make it a private list.
* Don't pass Chunk in SlotDone.

SocketManager must be enabled.

Use ProtocolBuffer for skip piece too.

Make the stable buffer in throttle be more dynamic depending on the current rate.

Optimize ChokeManager::get_unchoked.

Add buffer read of piece.

Fix tracker so it checks regulary when too few peers are connected.

Lock file in session directory.


POLLING:

Consider sorting SocketSet so we can get maxFd cheaper. Epoll might
not need this, so consider the value.

Rename poll.h.


CLEANUP:

ref_anchored... urgh...


BUGS:

Snubing seems borked... why?

Possible bug when doing sync on torrents > 4.2GB, over NFS.

Don't use function pointers in throttle, templates should work as well.

Throttle might not give correct size when for_each'ing each, since zero byte quotas might accure.


RELEASE:

[CHECK] Move download management out of core::Manager, use slots to do stuff
upon torrent open/close, start/stop etc.

Consider adding is_active/is_open checks to DownloadList.

Option to check hash after download.

Save state information.

Remove read/write_chunk exceptions.

Possibly do sync before/after checking hash. Don't sync complete
chunks as they were synced at the time of hash checking? Read the list
of dirty chunks from the delegator. Need to fix the problem of corrupt
downloads due to lack of diskspace.

Do truncate to update the timestamp, so we know he filestamp is updated.

Do sync on all stopped downloads. Ftruncate a torrent upon load to set its timestamp.

Fix TaskSchedule's static init sequence problem.

Create a man page.


NEXT RELEASE:

Clear the screen after shutdown.
