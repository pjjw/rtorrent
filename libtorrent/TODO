'*' Things are stuff that *must* be done by the next release.
'!' Things are stuff that MUST MUST MUST be done ASAP.

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Set IP TOS

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Recursively update the up/down rates in throttle.

Make a seperate class for doing read and write to buffer in PC.

Each throttle can have it's own rules to decide the priority it gets.

Frobnicate the tracker reconnect timeout.

Switch to a proper type for file offset/length and chunk length. A proper
type for chunk index.

! Make sure that a peer sending a piece, but being choked throws a
communication error, not a internal error.

! Why is the client lagging when downloading a http torrent? Looks like dnsdomainlookup

std::isalpha in escape string

Consider not calling insert_write() when filling have list.

storage_consolidator get_chunk takes to many arguments, use flags instead.

File::get_chunk() needs to have error for improper permission access, and stuff.

Store data on which side inititalized the connection.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


FUTURE

Enable torrents with hugh number of files by downloading to a single
file then splitting it up? Rather, open files as needed.


DELEGATOR STUFF

* Add message about pieces being ignored, so i can test the code.

Proper canceling of pieces in sendHave, unless only one can download a
piece.

* Make endgameBorder do pieces instead of chunks.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


TRACKER STUFF

Add/change tracker.


API REDESIGN:

Exceptions are pushed out with signals, support different groups with
multiple signals.

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?

Bitfield class needs to use unsigned char


OPTIMIZING

SocketBase should use a stl::vector instead. This would require a
function that iterates through the vector and set new valid iterators
after a reserve/erase.

Using lists for the sockets we're waiting on does provide for many
cache misses. (i would assume). find out if you can't use something more
clever. Sort by fd number? iterate only to that number?

Cache iterators to different borders, and update them as we add/remove?

Use iterators in StorageChunk::get_position instead.

Look into epoll.


DUMPING TORRENT FILES

Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.


IMPORTANT

make sure handshake gets "" id if the download does not want connections,
or some other filter system.

Clean up the m_checked flag in DownloadMain::start/stop/foo.



RTORRENT RELATED


DOCUMENTATION

As far as documentation is concerned: a step through example that shows all
the torren::init calls and sets up a download and doxygen comments in the
header files would be great.


TODO NOW
