SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A proper
type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


LONG TERM:

Make a collection of stuff in utils that can be shared between apps.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Look into epoll and sendfile.


DUMPING TORRENT FILES

Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.


IMPORTANT

make sure handshake gets "" id if the download does not want connections,
or some other filter system.

DOCUMENTATION

As far as documentation is concerned: a step through example that shows all
the torren::init calls and sets up a download and doxygen comments in the
header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


BUGS:

SigPipe, make a signal handler that dumps stack.

Check if CXXFLAGS is set.

Snubing seems borked... why?

CURRENT:

Move mkdir stuff out of Path?

Cleanup HashQueue, seperate out nodes etc.
* Make it a private list.
* Don't pass Chunk in SlotDone.

Make HashChunk::remaining inline.

SocketManager must be enabled.


NEXT:

Use ProtocolBuffer for skip piece too.

Make the stable buffer in throttle be more dynamic depending on the current rate.

Optimize ChokeManager::get_unchoked.


NEXT:

Make a base class for PeerConnection, move read/write_remaining etc.

Add buffer read of piece.

Fix tracker so it checks regulary when too few peers are connected.


RELEASE:

Remove debug checks in SocketSet. (Next release)


POLLING:

Consider sorting SocketSet so we can get maxFd cheaper. Epoll might
not need this, so consider the value.

Rename poll.h.


CLEANUP:

ref_anchored... urgh...


FIFO QUEUE:

#CXXFLAGS

signal(SIGPIPE, SIG_IGN);

Bind socket
bind different local ip in rtorrent

segfault when starting with the -s option - 1400 anonymous calls.
rtorrent -s /tmp -p 11080-11090 a.torrent b.torrent

Program received signal SIGABRT, Aborted.

Hash checking queue in client must support deleting of torrents.

Caught exception: "Connection read fd(51) state(5) "Peerconnection::read()
tried to read a piece but is not in throttle list""

display bug - end of filelist

reenable checks in SocketSet, ponder the possibility it can overflow.