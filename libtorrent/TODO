NOTE: These are personal TODO items that might, or might not be
implemented. They are just notes to keep me from forgetting ideas i
get while coding.

[PARTLY] Allow for easier configuration for very low/very high open
max. Add notes to wiki.

Make a new file_list or something like that. It should not care about
chunk size etc, only hold the list of whatever replaces StorageFile's.

Make it possible to disable certain files, not causing an error when
they don't give rw perm or resize?

Move stuff into rak.

Slot in torrent/Peer for incoming, so we can use SocketAddress
internally?

Re-add slot for removing incoming connections from available list? If
so, remove the check in connect_peers.

Move endgame detection to delegator?

Get rid of DownloadNet and DownloadState, use only DownloadMain.

Move DownloadMain::get_name to DownloadWrapper?

Add a setting for overridding open max, only less than. Remove the
other settings?

Make sure rtorrent's http downloading times out.

Different min peers for seeding and leeching modes?

Rename TrackerControl?

Remove get_ for certain class of accesses, also make them pointers to
put emphasis on the fact that they arn't logically behaving like
return-by-value types.

Add an intersection version off HandshakeManager::has_address()?

Clean up the header includes around the codebase, need to reduce the
amount of memory required to compile libtorrent.

Make a seperate Download tracker class thing that handles re-requests
etc. Move control logic from TrackerControl.

Send mail to OpenBSD to see how they handle madvise.

Use a seperate function for handling epoll_ctl calls? With event and
op as args?

Consider renaming Poll::open/close.

Add more checks to PollEPoll, like < -1 and > max_socket.

Move ui::Control to src/, make the initialization functions part of it.

Improve the settings code, it should read all settings before
initialization. Make some seperate settings class that holds all the
settings, that the user can view during runtime.

Look over the max open sockets settings etc, it should be
consistent. One should have a choice between using a setting that
changes sysconf(_SC_OPEN_MAX), or get the max value from this variable.

Figure out the ElementStringList already activated bug.

* Test socket manager by setting a low open max and connecting to a
busy torrent. Consider testing ulimit -n too.

Add a setting for controlling whetever allocate is called at torrent
creation, chunk creation or not at all.

XFS reserve should check for error return code, if it fails due to
lack of diskspace it should return false, otherwise true.

The hash checking options should be per byte, so they work for all sized
chunks.

Add failure if no trackers were connected to in a cycle.

Update displaying of trackers, add key for disabling/enabling them.

Clean up the settings code by moving the validation to the apply'er.

Use typedef for port?

Add filter for ip address, and peer id. These must be seperate as ip
happens before handshake, but peer id is done after handshake or
before connecting.

Move utilities into rak/.

Make the tries adjuster into a setting.

Doesn't force in some cases when the system is overloaded and you got
small hash chunks.

Fix hash checking slowness on overworked boxens. Possibly mark the
mmap'ed area as sequential. Add options to the man page.

Expand ~/ in input.

Rewrite the chunk handler, use a vector that msyncs continious chunks
when it feels like it. Use a task to check periodically, or when
receiving chunks. Try to make sure we do sequential download of
chunks, instead of completely random.

Add a slot in core::DownloadList that makes it safe to delete
downloads at all times.

Check if BT 4.0.2 has problems with libtorrent.

Use a seperate function for checking the hash status when doing
download starts.

Possibly do sync before/after checking hash. Don't sync complete
chunks as they were synced at the time of hash checking? Read the list
of dirty chunks from the delegator. Need to fix the problem of corrupt
downloads due to lack of diskspace.

Do truncate to update the timestamp, so we know he filestamp is
updated.

Do sync on all stopped downloads. Ftruncate a torrent upon load to set
its timestamp.

Rewrite the read buffering in PeerConnection, don't do so many small
reads.

Ponder race condition on lazy hash checking, do new data get written
before we start checking?

The handling of hash fails isn't good enough...

Directory validation needs to be lazy?

Disable read/write_chunk exceptions.

Don't allow many handshakes from the same ip?

Copy modifications of timer.h to rtorrent. Wait... first from rtorrent to libtorrent.

Create a std::list'ish thing that contains the current downloads, and
expose it to the client. Will make DownloadManager 'redundant'. Don't fix?



*** STUFF I MIGHT DO SOME DAY ***

SMALL TODO STUFF I HAVEN'T BOTHERED DOING YET:

After 25 seconds, choke a peer if no requests have been received?

Add average, max and total to rates. Will this be controlled by
choke/unchoke?

Add a snub factor. The more you upload without getting back, the
higher it goes. Add a start buffer.

Add config for how often we unchoke unknown peers vs good uploaders

Each throttle can have it's own rules to decide the priority it gets.

Switch to a proper type for file offset/length and chunk length. A
proper type for chunk index.

std::isalpha in escape string

Store data on which side inititalized the connection.

torrent::Http::call_cleanup to delete the factory created object?

If we get conflicting prot flags in get_chunk, we might go into cycle
of re-allocating. Do a union instead.


LONG TERM:

Make a collection of stuff in utils that can be shared between apps.


TIMER RELATED

Throttle update needs to be off when no throttle is on. Make sure it
doesn't bork with using up allocated bytes.


DELEGATOR STUFF

Proper canceling of pieces in sendHave, unless only one can download a
piece.

Make set endgame take priorities into account.

Don't be so aggressive at selecting stalled pieces.


API REDESIGN:

Changing the piece length.


AFTER API REDESIGN:

Add the option to not throw non-critical exceptions. This lets the
client be ignorant of errors while creating stuff. (Make some kind of
C friendly layer ontop)

Consider ways of optimizing bitfield memory usage. A bitfield with all
set shouldn't change ever... And do a count on number of set bits?


OPTIMIZING

Look into epoll and sendfile.


Does it make sense to have *.bt_part or similar suffixes on partially
downloaded files? This would be uncompatible with other clients, but
make it configurable? This is fully client side, though need to
support a way to move files.

make sure handshake gets "" id if the download does not want
connections, or some other filter system.

DOCUMENTATION

As far as documentation is concerned: a step through example that
shows all the torren::init calls and sets up a download and doxygen
comments in the header files would be great.


TRACKER STUFF

Make sure adding trackers doesn't invalidate current requests,
disallow for open torrents?


Move mkdir stuff out of Path?

Cleanup HashQueue, seperate out nodes etc.  * Make it a private list.
* Don't pass Chunk in SlotDone.

SocketManager must be enabled.

Use ProtocolBuffer for skip piece too.

Make the stable buffer in throttle be more dynamic depending on the
current rate.

Optimize ChokeManager::get_unchoked.

Add buffer read of piece.

Fix tracker so it checks regulary when too few peers are connected.

Lock file in session directory.


POLLING:

Consider sorting SocketSet so we can get maxFd cheaper. Epoll might
not need this, so consider the value.

Rename poll.h.


CLEANUP:

ref_anchored... urgh...


BUGS:

Snubing seems borked... why?

Don't use function pointers in throttle, templates should work as well.

Throttle might not give correct size when for_each'ing each, since
zero byte quotas might accure.
