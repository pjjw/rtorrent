== API changes ==

A disk setting manager, allow change of read-ahead etc.

The seed count and scrape leech/seed.

Disk cache.

Resume needs to be split.

Add interface for getting currently downloading chunks. Don't use thin
wrappers here?

Add helpers to Object::get_key


=== torrent::Object ==

Ways of checking that they are a value and between a range.


=== Session management ==

Add a command to tie a torrent to the life-time of a file. When that
file is deleted, stop or delete the torrent.

To support this, use different states (enum) for each torrent;
STOPPED, STARTED, DEFUNCT(?), LOADING(?), SCHEDULED. When this is
available, it should be possible to temporarily stop all torrents and
remove DEFUNCT when quitting rtorrent. The latter could be used when
the user deletes the file it is tied to.

Saving session torrents should be lazy, perhaps only for those who are
not open. Or do session torrent saving as needed, when seeding is
stopped etc. Perhaps a dirty flag.

Mark files in the session torrent that we know have been created. Thus
we can bork if we find anything missing.


== Global and Download specific variables ==

There are various things, ties to files, peer connection type etc that
should be in a generic variable container thingie. In addition there
should be a template for new downloads, download factory etc. The
download factory's being given to the new download.

Remember that we currently don't save sessions for inactive torrents.

Some variables should have custom store/retrive slots. One kind could
be used to store/retrive values from the bencoded data, with syntax
like "rtorrent/state" etc.

Stuff about new bencode thingie.

Make it possible to do an validity check on a bencode stream.


== Cleanup of the display manager ==

Consider taking the tasks out of the Window class, and just use flags
for those that want to be regulary updated.


== Configurable keybindings ==

...


== Delegator rework ==

Keep multiple downloads of the same block seperate. When done, and
hash checking fails, compare pieces and merge/mark equal pieces. Those
would have higher priority when comparing, but not absolute.

The anonymous mmap'ed regions would contain different dtor functor
than file chunks.

We need to keep around PeerInfo's after peers disconnect, so we store
information for longer that the immediate connection. This also eases
the delegator since we can use pointers to identify the peer we
downloaded the piece from.

Get rid of affinity, perhaps each peer saves the pointer to the
delegator chunk they are currently using, in addition to the delegator
piece.


Re-enable randomized selector position.

Do the range-disable and position moving in d selector.


== Sockets ==

Look into increasing the socket buffers. This would allow us to queue
more data for each poll event. But make sure we only get polled when
the buffer can take a nice amount of data.

The goal would be to push as much data into the buffer per event as
possible if it is uploading fast.


== Improve logging ==

...


== Disk worker thread ==

A worker thread that gets activated to do stuff like hashing and
syncing to disk. This would have the benefit of avoiding SIGBUS due to
full disk as msync can be called blockingly.

Before work can start on this, a threading library needs to be
available. Possibly the TR2 stuff?


== Tracker scrape ==

Add tracker scraping and display connected/not-connected seeds and
leechers.

In the mean time, parse the extra information the official tracker
transmits on requests.


== typedefs or more restrictive types for chunk indices, ports and such ==

These would include defines for invalid states etc.


== Validate the presence of files for session torrents ==

Make sure that when session torrents are opened, it ensures that the
downloaded/ing files are where we last saw them. Libtorrent shouldn't
create the files when opened, but perhaps a call can be added for
trying to make them?


== Added initialization stuff to sections in the elf file? ==

Stuff like adding stuff to the ClientInfo object could be done from
with a resource file embedded in the executable.
